import { defineEventHandler, getQuery, createError, setHeader } from "h3";
import { prisma } from "../../utils/prisma";
import { anilistRequest } from "../../services/anilist/anilistClient";
import crypto from "crypto";

/* ----------------------------------
 * Config
 * ---------------------------------- */
const EXCLUDED_STATUSES = new Set(["COMPLETED", "WATCHING"]);

const CACHE_TTL_ANILIST = 1000 * 60 * 5;

/* ----------------------------------
 * Scoring Configuration
 * ---------------------------------- */
const GENRE_WEIGHT = 1.5; // Gewicht pro gematchtem Genre
const TAG_WEIGHT = 1.0; // Gewicht pro gematchtem Tag
const NORMALIZATION_MODE: "sqrt" | "linear" = "sqrt"; // Normalisierung gegen Match-Anzahl

// Progressive Penalty-Kurve: wenige Matches werden stark bestraft
const MATCH_PENALTY_CURVE = {
  1: 0.15, // Einzelmatch ‚Üí extrem schwach
  2: 0.45, // Zwei Matches ‚Üí noch stark ged√§mpft
  3: 0.8, // Drei Matches ‚Üí fast normal
};
const MIN_MATCH_COUNT = 3; // Zielwert f√ºr ‚Äûsaubere‚Äú Empfehlungen
const MULTI_GENRE_BONUS = 1.2; // Bonus wenn mehrere Genres matchen

// Obergrenze f√ºr einzelne Tags, um Dominanz einzelner Extrem-Tags zu verhindern
const MAX_SINGLE_TAG_CONTRIBUTION: number | null = 300;

/* ----------------------------------
 * Quality Scoring
 * ---------------------------------- */
const USE_AVERAGE_SCORE = true; // Aktiviert Qualit√§tsgewichtung
const MIN_AVERAGE_SCORE: number | null = 60; // Untere Grenze ‚Üí darunter wird komplett verworfen
const AVG_SCORE_BASELINE = 75; // Referenzwert f√ºr Multiplikator
const AVG_SCORE_MIN_MULTIPLIER = 0.7; // Untere Schranke
const AVG_SCORE_MAX_MULTIPLIER = 1.3; // Obere Schranke

const NOW = new Date();
/* ----------------------------------
 * Global Tag / Genre Frequency (IDF)
 * ---------------------------------- */
type GlobalStats = {
  tagCount: Map<number, number>;
  genreCount: Map<string, number>;
  totalAnime: number;
};

async function loadGlobalStats(anime: any[]): Promise<GlobalStats> {
  const tagCount = new Map<number, number>();
  const genreCount = new Map<string, number>();

  for (const a of anime) {
    for (const g of a.genres) {
      genreCount.set(g.name, (genreCount.get(g.name) ?? 0) + 1);
    }
    for (const t of a.tags) {
      tagCount.set(t.tagId, (tagCount.get(t.tagId) ?? 0) + 1);
    }
  }

  return {
    tagCount,
    genreCount,
    totalAnime: anime.length,
  };
}

function idf(globalCount: number, total: number) {
  return Math.log((1 + total) / (1 + globalCount));
}

/* ----------------------------------
 * Helpers (Query Parsing)
 * ---------------------------------- */
function mapToSortedArray<K>(
  m: Map<K, number>,
  limit: number
): { key: K; value: number }[] {
  return [...m.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, limit)
    .map(([key, value]) => ({ key, value }));
}

function calcStats(values: number[]) {
  if (!values.length) return { count: 0, min: 0, max: 0, avg: 0, sum: 0 };

  let sum = 0;
  let min = values[0];
  let max = values[0];

  for (const v of values) {
    sum += v;
    if (v < min) min = v;
    if (v > max) max = v;
  }

  return {
    count: values.length,
    min: Number(min.toFixed(3)),
    max: Number(max.toFixed(3)),
    avg: Number((sum / values.length).toFixed(3)),
    sum: Number(sum.toFixed(3)),
  };
}

function parseNumber(v: any): number | null {
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}

function parseList(v: any): string[] | null {
  if (!v || typeof v !== "string") return null;
  return v
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);
}

function hasStartDate(a: any) {
  return a.startYear !== null;
}

function isReleased(a: any) {
  // ‚ùå kein Jahr ‚Üí niemals released
  if (typeof a.startYear !== "number") return false;

  // ‚ùå nur Jahr bekannt ‚Üí zu ungenau ‚Üí schlechte Recommendation
  if (typeof a.startMonth !== "number") return false;

  const y = a.startYear;
  const m = a.startMonth;
  const d = typeof a.startDay === "number" ? a.startDay : 1;

  // Anime gilt ab dem fr√ºhestm√∂glichen Datum als released
  const releaseDate = new Date(y, m - 1, d);
  return releaseDate <= NOW;
}

/* ----------------------------------
 * AniList Cache
 * ---------------------------------- */
const anilistCache = new Map<
  string,
  {
    at: number;
    data: { mediaId: number; status: string; score: number | null }[];
  }
>();

/* ----------------------------------
 * AniList Query
 * ---------------------------------- */
const ANILIST_LIST_QUERY = `
query ($userName: String!) {
  MediaListCollection(userName: $userName, type: ANIME) {
    lists {
      entries {
        status
        score(format: POINT_10)
        media { id }
      }
    }
  }
}
`;

async function loadUserAnilistEntries(user: string) {
  const hit = anilistCache.get(user);
  const now = Date.now();
  if (hit && now - hit.at < CACHE_TTL_ANILIST) return hit.data;

  const res: any = await anilistRequest(ANILIST_LIST_QUERY, { userName: user });
  const out: any[] = [];

  for (const l of res?.MediaListCollection?.lists ?? []) {
    for (const e of l.entries ?? []) {
      if (!e?.media?.id) continue;
      out.push({
        mediaId: e.media.id,
        status: String(e.status),
        score: typeof e.score === "number" ? e.score : null,
      });
    }
  }

  anilistCache.set(user, { at: now, data: out });
  return out;
}

/* ----------------------------------
 * Taste Profile
 * ---------------------------------- */
type TasteProfile = {
  genres: Map<string, number>;
  tags: Map<number, number>;
  negativeGenres: Map<string, number>;
  negativeTags: Map<number, number>;
};

function buildTasteProfile(
  completedIds: number[],
  scoreById: Map<number, number | null>,
  animeById: Map<number, any>,
  global: GlobalStats,
  debug?: { user?: string; topN?: number; log?: boolean }
): TasteProfile {
  const genres = new Map<string, number>();
  const tags = new Map<number, number>();
  const negativeGenres = new Map<string, number>();
  const negativeTags = new Map<number, number>();

  const weights: number[] = [];

  for (const id of completedIds) {
    const a = animeById.get(id);
    if (!a) continue;

    const s = scoreById.get(id) ?? 5;
    const weight = s / 10; // üîπ Schritt 4: Z-Score-light
    weights.push(weight);

    const isNegative = s <= 4;
    if (s === 5) continue; // Neutral ‚Üí ignorieren
    for (const g of a.genres) {
      const idfWeight = idf(
        global.genreCount.get(g.name) ?? 1,
        global.totalAnime
      );
      const w = weight * idfWeight;

      if (isNegative) {
        negativeGenres.set(
          g.name,
          (negativeGenres.get(g.name) ?? 0) + Math.abs(w)
        );
      } else {
        genres.set(g.name, (genres.get(g.name) ?? 0) + w);
      }
    }

    for (const t of a.tags) {
      const idfWeight = idf(
        global.tagCount.get(t.tagId) ?? 1,
        global.totalAnime
      );
      const w = weight * idfWeight;

      if (isNegative) {
        negativeTags.set(
          t.tagId,
          (negativeTags.get(t.tagId) ?? 0) + Math.abs(w)
        );
      } else {
        tags.set(t.tagId, (tags.get(t.tagId) ?? 0) + w);
      }
    }
  }

  // üîπ Schritt 3: Soft-Cap / S√§ttigung
  function soften<K>(m: Map<K, number>) {
    for (const [k, v] of m) {
      m.set(k, Math.sign(v) * Math.log1p(Math.abs(v)));
    }
  }
  function cap<K>(m: Map<K, number>, max: number) {
    for (const [k, v] of m) {
      m.set(k, Math.min(v, max));
    }
  }

  cap(negativeGenres, 2.5);
  cap(negativeTags, 3.0);
  soften(genres);
  soften(tags);
  soften(negativeGenres);
  soften(negativeTags);

  if (debug?.log) {
    console.log(`\n[TasteProfile+Advanced] user=${debug.user}`);
    console.log("Top Positive Genres", mapToSortedArray(genres, 15));
    console.log("Top Negative Genres", mapToSortedArray(negativeGenres, 15));
    console.log("Top Positive Tags", mapToSortedArray(tags, 15));
    console.log("Top Negative Tags", mapToSortedArray(negativeTags, 15));
  }

  return { genres, tags, negativeGenres, negativeTags };
}

/* ----------------------------------
 * Scoring
 * ---------------------------------- */
function scoreAnime(anime: any, taste: any) {
  let rawScore = 0;

  const matchedGenres: string[] = [];
  const matchedTags: string[] = [];

  // Genre-Matches addieren
  for (const g of anime.genres) {
    const w = taste.genres.get(g.name);
    if (w) {
      rawScore += w * GENRE_WEIGHT;
      matchedGenres.push(g.name);
    }
  }

  // Tag-Matches addieren (mit Cap)
  for (const t of anime.tags) {
    let w = taste.tags.get(t.tagId);
    if (!w) continue;

    if (MAX_SINGLE_TAG_CONTRIBUTION !== null) {
      w = Math.min(w, MAX_SINGLE_TAG_CONTRIBUTION);
    }

    rawScore += w * TAG_WEIGHT;
    matchedTags.push(t.name);
  }

  const matchCount = matchedGenres.length + matchedTags.length;

  // Keine oder zu wenige Matches ‚Üí direkt raus
  if (!matchCount) return { score: 0, matchedGenres, matchedTags };
  if (matchCount < MIN_MATCH_COUNT)
    return { score: 0, matchedGenres, matchedTags };

  // Normalisierung gegen Anzahl der Treffer
  let score =
    NORMALIZATION_MODE === "sqrt"
      ? rawScore / Math.sqrt(matchCount)
      : rawScore / matchCount;

  // Progressive Strafe f√ºr geringe Match-Breite
  score *= MATCH_PENALTY_CURVE[matchCount] ?? 1;
  // üîª Negativ-Taste anwenden
  for (const g of matchedGenres) {
    const neg = taste.negativeGenres?.get(g);
if (neg) score -= neg * 0.15;
  }

  for (const t of anime.tags) {
    if (!taste.tags?.has(t.tagId)) continue; // üî• WICHTIG
    const neg = taste.negativeTags?.get(t.tagId);
   if (neg) score -= neg * 0.08;
  }

  const hasGenre = matchedGenres.length > 0;
  const hasTag = matchedTags.length > 0;

  // Reiner Einzel-Tag ohne Genre ‚Üí extrem abwerten
  if (matchedTags.length === 1 && matchedGenres.length === 0) {
    score *= 0.2;
  }

  // Fehlt entweder Genre oder Tag ‚Üí starke Abwertung
  if (!(hasGenre && hasTag)) {
    score *= 0.3;
  }

  // Bonus f√ºr Breite (mehr unabh√§ngige Treffer)
  const breadthBonus = Math.log2(1 + matchedGenres.length + matchedTags.length);
  score *= breadthBonus;

  // Extra-Bonus f√ºr mehrere Genres
  if (matchedGenres.length >= 2) score *= MULTI_GENRE_BONUS;

  // Qualit√§tsgewichtung √ºber AverageScore
  if (USE_AVERAGE_SCORE && typeof anime.averageScore === "number") {
    if (MIN_AVERAGE_SCORE !== null && anime.averageScore < MIN_AVERAGE_SCORE) {
      return { score: 0, matchedGenres, matchedTags };
    }

    const q = anime.averageScore / AVG_SCORE_BASELINE;
    score *= Math.min(
      AVG_SCORE_MAX_MULTIPLIER,
      Math.max(AVG_SCORE_MIN_MULTIPLIER, q)
    );
  }

  return { score, matchedGenres, matchedTags };
}

/* ----------------------------------
 * Chain Logic
 * ---------------------------------- */
const ROOT_REL = new Set(["PREQUEL", "PARENT"]);
const SEQUEL_REL = "SEQUEL";

function pickDeterministic<T extends { toId: number }>(edges: T[]) {
  return [...edges].sort((a, b) => a.toId - b.toId)[0] ?? null;
}

function buildChainMap(relations: any[]) {
  const byId = new Map<number, any>();
  relations.forEach((a) => byId.set(a.id, a));

  function findRoot(start: any) {
    let current = start;
    const visited = new Set<number>();
    while (true) {
      if (visited.has(current.id)) break;
      visited.add(current.id);

      const prequels = (current.relationsFrom ?? [])
        .filter((r: any) => ROOT_REL.has(r.relationType))
        .filter((r: any) => r.toId !== current.id);

      const next = pickDeterministic(prequels);
      if (!next) break;

      const node = byId.get(next.toId);
      if (!node) break;
      current = node;
    }
    return current;
  }

  const chainByAnimeId = new Map<number, number[]>();

  for (const a of relations) {
    const root = findRoot(a);
    let current = root;
    const chain: number[] = [];
    const visited = new Set<number>();

    while (true) {
      if (visited.has(current.id)) break;
      visited.add(current.id);
      chain.push(current.id);

      const sequels = (current.relationsFrom ?? [])
        .filter((r: any) => r.relationType === SEQUEL_REL)
        .filter((r: any) => r.toId !== current.id);

      const next = pickDeterministic(sequels);
      if (!next) break;

      const node = byId.get(next.toId);
      if (!node) break;
      current = node;
    }

    for (const id of chain) {
      chainByAnimeId.set(id, chain);
    }
  }

  return chainByAnimeId;
}

function isFirstUnseenInChain(
  animeId: number,
  chainMap: Map<number, number[]>,
  excludedIds: Set<number>
) {
  const chain = chainMap.get(animeId);
  if (!chain) return true;

  for (const id of chain) {
    if (!excludedIds.has(id)) {
      return id === animeId;
    }
  }
  return false;
}

/* ----------------------------------
 * Handler
 * ---------------------------------- */
export default defineEventHandler(async (event) => {
  setHeader(event, "Cache-Control", "public, max-age=60");

  const q = getQuery(event);
  const user = q.user;
  const includeUpcoming =
    q.includeUpcoming === "true" || q.includeUpcoming === "1";

  if (!user || typeof user !== "string") {
    throw createError({ statusCode: 400, statusMessage: "Missing user" });
  }

  const filterSeason =
    typeof q.season === "string" ? q.season.toUpperCase() : null;

  const seasonYearMin = parseNumber(q.seasonYearMin);
  const seasonYearMax = parseNumber(q.seasonYearMax);

  const episodesMin = parseNumber(q.episodesMin);
  const episodesMax = parseNumber(q.episodesMax);

  const avgScoreMin = parseNumber(q.averageScoreMin);
  const avgScoreMax = parseNumber(q.averageScoreMax);

  const includeGenres = parseList(q.genres);
  const excludeGenres = parseList(q.excludeGenres);

  const includeTags = parseList(q.tags);
  const excludeTags = parseList(q.excludeTags);

  /* 1) User list */
  const userEntries = await loadUserAnilistEntries(user);

  const excludedIds = new Set<number>();
  const completedIds: number[] = [];
  const scoreById = new Map<number, number | null>();

  for (const e of userEntries) {
    scoreById.set(e.mediaId, e.score);
    if (EXCLUDED_STATUSES.has(e.status)) excludedIds.add(e.mediaId);
    if (e.status === "COMPLETED") completedIds.push(e.mediaId);
  }

  const storage = useStorage("cache");
  const animeKey =
    "anime-db" + crypto.createHash("sha1").update("anime-db").digest("hex");
  const relKey =
    "anime-relation:" +
    crypto.createHash("sha1").update("anime-relation").digest("hex");

  const anime =
    (await storage.getItem<any[]>(animeKey)) ??
    (await prisma.anime.findMany({
      where: { format: { in: ["TV", "MOVIE"] } },
      include: { genres: true, tags: true },
    }));

  await storage.setItem(animeKey, anime, { ttl: 60 * 60 * 8 });

  const relations =
    (await storage.getItem<any[]>(relKey)) ??
    (await prisma.anime.findMany({
      include: { relationsFrom: true, relationsTo: true },
    }));

  await storage.setItem(relKey, relations, { ttl: 60 * 60 * 48 });

  const chainMap = buildChainMap(relations);

  const animeById = new Map(anime.map((a) => [a.id, a]));
  const globalStats = await loadGlobalStats(anime);

  const taste = buildTasteProfile(
    completedIds,
    scoreById,
    animeById,
    globalStats,
    { user, topN: 30, log: true }
  );

  const recs: any[] = [];

  for (const a of anime) {
    if (excludedIds.has(a.id)) continue;

    // ‚ùå kein Startdatum ‚Üí nie empfehlen
    if (!hasStartDate(a)) continue;

    // ‚ùå Upcoming nur wenn explizit erlaubt
    if (!includeUpcoming && !isReleased(a)) continue;

    // üîπ Season-Filter
    if (filterSeason && a.season !== filterSeason) continue;

    // üîπ Year-Filter (JETZT korrekt auf startYear)
    if (seasonYearMin !== null && (a.startYear ?? 0) < seasonYearMin) continue;
    if (seasonYearMax !== null && (a.startYear ?? 9999) > seasonYearMax)
      continue;

    // üîπ Episoden
    if (episodesMin !== null && (a.episodes ?? 0) < episodesMin) continue;
    if (episodesMax !== null && (a.episodes ?? Infinity) > episodesMax)
      continue;

    // üîπ Average Score
    if (avgScoreMin !== null && (a.averageScore ?? 0) < avgScoreMin) continue;
    if (avgScoreMax !== null && (a.averageScore ?? Infinity) > avgScoreMax)
      continue;

    // üîπ Chain-Logik
    if (!isFirstUnseenInChain(a.id, chainMap, excludedIds)) continue;

    const { score, matchedGenres, matchedTags } = scoreAnime(a, taste);
    if (score <= 0 || matchedTags.length === 0) continue;

    // üîπ Genre Include / Exclude
    if (includeGenres && !matchedGenres.some((g) => includeGenres.includes(g)))
      continue;

    if (excludeGenres && matchedGenres.some((g) => excludeGenres.includes(g)))
      continue;

    // üîπ Tag Include / Exclude
    if (includeTags && !matchedTags.some((t) => includeTags.includes(t)))
      continue;

    if (excludeTags && matchedTags.some((t) => excludeTags.includes(t)))
      continue;

    recs.push({
      id: a.id,
      titleEn: a.titleEn,
      titleRo: a.titleRo,
      cover: a.cover,
      format: a.format,
      score: Number(score.toFixed(3)),
      averageScore: a.averageScore,
      season: a.season,
      seasonYear: a.startYear, // ‚Üê bewusst!
      episodes: a.episodes,
      matchedGenres,
      matchedTags,
    });
  }

  recs.sort((a, b) => b.score - a.score);

  return {
    user,
    total: recs.length,
    items: {
      TV: recs.filter((r) => r.format === "TV").slice(0, 100),
      MOVIE: recs.filter((r) => r.format === "MOVIE").slice(0, 100),
    },
  };
});
